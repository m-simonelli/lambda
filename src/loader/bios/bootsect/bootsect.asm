[org 0x7c00]
[bits 16]

%include "defs.inc" ; generated by make
%define STACK_START 0x8000

start:
    jmp .bpb_end

    ; some BIOSes overwrite where there would be a FAT BPB,
    ; which will be 90 bytes at largest for a FAT16 BPB
    times 88 db 0

    align 4
  .bpb_end:
    cli
    cld
    ; load cs
    jmp 0x0:.initcs
  .initcs:
    xor ax, ax
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax
    mov ss, ax
    
    ; setup stack at 0x8000
    mov bp, STACK_START
    mov sp, bp

    sti

    ; clear screen
    call clr_scrn

    ; fix disk num since some bioses don't set it properly
    call fix_disk_num

    ; check for disk extensions support
    call check_drive_ext_supported

    ; no guarantee on upper half of esp
    mov esp, 0x7c00

    ; load S2 at 0x9000 (0x900:0x0)
    push 0
    pop es
    xor bx, bx
    push 0x9000
    pop bx
    ; start reading from sector 1
    xor eax, eax
    inc al
    ; as many sectors as needed to load all of S2
    mov cx, S2_SEC_CNT
    call lba_sector_read
    ; TODO: something better than just halting on an incorrect read
    jc rm_err

    ; enter 32 bit protected mode
    cli
    lgdt [gdt.descriptor]
    mov eax, cr0
    or eax, 1
    mov cr0, eax

    ; reload cs
    jmp CODE_SEG:pmode_start

rm_err:
    hlt
    jmp rm_err

%include "gdt.asm"
%include "screen.asm"
%include "disk.asm"

[bits 32]
pmode_start:
    mov ax, 0x10
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax
    mov ss, ax

    jmp 0x9000

; boot signature
times 510-($-$$) db 0
dw 0xaa55